pragma solidity ^0.5.3;

/**
* @title SafeMath
* @dev Math operations with safety checks that throw on error
*/
library SafeMath {
    /**
    * @dev Adds two numbers, reverts on overflow.
    */
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    
    /**
    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    
    /**
    * @dev Multiplies two numbers, reverts on overflow.
    */
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    
    /**
    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        return c;
    }
}

/** 
@dev AuthentiicateInterface for Autheticate our contract.
*/
contract AuthentiicateInterface{
    function checkforAuthContract(address contractaddress) public view returns (bool);
}

/** 
*@dev Upgred is abstract class that provide methods thay must have by who address, we upgraded our contract.
*/
contract Upgred {
    function transferByLegacy(address from, address to, uint tokens,bytes memory data) public returns (bool success);
    function convertByLegacy(address to, uint tokens) public;
    function balanceOfByLegecy(address _owner)public view returns(uint balance);
}

/**
* @dev ERC223Interface is abstract class that we used for implements erc223 Standard.
*/
contract ERC223Interface {

    function balanceOf(address tokenOwner) public view returns (uint balance);
    function transfer(address to, uint tokens) public returns (bool success);
    function transfer(address to, uint tokens, bytes memory data)public returns (bool success);
    
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens, bytes data);
}

/**
*@dev ContractReceiver abstract class that define by erc223, the method tokenFallback must by receiver contract if it want 
* to accept erc223 tokens.
*/
contract ContractReceiver {
    function tokenFallback(address _from, uint _value, bytes memory _data) public;
}

contract Ownable {
    address payable public owner;

    /** @dev The Ownable constructor sets the original `owner` of the contract to the sender account. */
    constructor() internal{
        owner = msg.sender;
    }

    /** @dev Throws if called by any account other than the owner.*/
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}

/** 
*@dev BlackList contract use for implements Add, Remove and get BlackList accounts.  
*/
contract BlackList is Ownable{
    mapping (address => bool) public isBlackListed;
    event AddedBlackList(address _user);
    event RemovedBlackList(address _user);
    
    ///// getBlackListStatus for check address is BlackListed or not /////
    function getBlackListStatus(address _maker) external view returns (bool) {
        return isBlackListed[_maker];
    }
    
    /** 
    * @dev addBlackList mothod only called by only Owner address. this method add address into BlackList.
    * @param _evilUser address that Owner address want to add in BlackList address.
    */
    function addBlackList (address _evilUser) public onlyOwner {
        require(!isBlackListed[_evilUser]);
        isBlackListed[_evilUser] = true;
        emit AddedBlackList(_evilUser);
    }

    /** 
    * @dev removeBlackList mothod only called by only Owner address. this method remove address from BlackList address.
    * @param _clearedUser address that Owner address want to remove in BlackList address.
    */
    function removeBlackList (address _clearedUser) public onlyOwner {
        require(isBlackListed[_clearedUser]);
        isBlackListed[_clearedUser] = false;
        emit RemovedBlackList(_clearedUser);
    }
}

/** 
*@dev erc223 contract that implements Standard ERC223. 
*/
contract erc223 is ERC223Interface,BlackList {
    
    /*veriables for count fees*/
    uint public basisPointsRate = 0;
    uint public minimumFee = 0;
    uint public maximumFee = 0;
    uint8 public decimals;

    mapping(address => uint) balances;
    using SafeMath for uint;
    
    /*events for fee*/
    event Params(uint feeBasisPoints,uint maximumFee,uint minimumFee); 
    event TransferWithFees(address from,address to,address owner,uint tokens,uint fees);
    
    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.
    function isContract(address _addr) public view returns (bool is_contract) {
        uint length;
        assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
        }
        return (length>0);
    }
  
    // Standard function transfer similar to ERC20 transfer with no _data .
    // Added due to backwards compatibility reasons .
    function transfer(address to, uint tokens,bytes memory data) public returns (bool success) {
        if(isContract(to)) return transferToContract(to, tokens, data);
        else return transferToAddress(to, tokens, data);
    }

    //function that is called when transaction target is an address
    function transferToAddress(address to, uint tokens, bytes memory data) private returns (bool success) {
        uint fee = calculateFee(tokens);
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        if (fee > 0) {
            tokens = tokens.sub(fee);
            balances[owner] = balances[owner].add(fee);
        }
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        emit Transfer(msg.sender, to, tokens, data);
        emit TransferWithFees(msg.sender,to,owner,tokens,fee);
        return true;
    }
  
    //function that is called when transaction target is a contract
    function transferToContract(address to, uint tokens, bytes memory data) private returns (bool success) {
        uint fee = calculateFee(tokens);
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        if (fee > 0) {
            tokens = tokens.sub(fee);
            balances[owner] = balances[owner].add(fee);
        }
        balances[to] = balances[to].add(tokens);
        ContractReceiver receiver = ContractReceiver(to);
        receiver.tokenFallback(msg.sender, tokens, data);
        emit Transfer(msg.sender, to, tokens);
        emit Transfer(msg.sender, to, tokens, data);
        emit TransferWithFees(msg.sender,to,owner,tokens,fee);
        return true;
    }
    
    /* ERC223 // Infers if whether _address is a contract based on the presence of bytecode */
    function calculateFee(uint _amount) internal view returns(uint){
        uint fee = (_amount.mul(basisPointsRate)).div(1000);
        if (fee > maximumFee) fee = maximumFee;
        if (fee < minimumFee) fee = minimumFee;
        return fee;
    }
    
    /*
    @dev Function to set the basis point rate .
    @param newBasisPoints uint which is <= 2.
    */
    function setParams(uint newBasisPoints,uint newMaxFee,uint newMinFee) public onlyOwner {
        // Ensure transparency by hardcoding limit beyond which fees can never be added
        require(newBasisPoints <= 9);
        require(newMaxFee <= 100);
        require(newMinFee <= 5);
        basisPointsRate = newBasisPoints;
        maximumFee = newMaxFee.mul(10**uint(decimals));
        minimumFee = newMinFee.mul(10**uint(decimals));
        emit Params(basisPointsRate, maximumFee, minimumFee);
    }
}

// Main contract for implements other Standard's methods 
contract Main is erc223{
    
    string public name;
    string public symbol;
    uint256 _totalSupply;
    address[] holder;
    bool depricated=false;
    bool public Autheticate=false;
    Upgred upgred;
    
    /*ERC621 Events*/
    event IncreaseSupply(uint amount);
    event DecreaseSupply(uint amount);
    //
    event DestroyedBlackFunds(address _blackListedUser,uint _balance);
  
    //IsAutheticate is modifier use to check contract is verifyed or not !!
    modifier IsAutheticate(){
        require(Autheticate==true);
        _;
    }
  
    constructor(string memory _name,string memory _symbol,uint8 _decimals,uint totalSupply) public{
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        _totalSupply = totalSupply * 10**uint(decimals);
        balances[msg.sender] = _totalSupply;
        setHolder(msg.sender);
    }
    
    //to get tot _totalSupply we use totalSupply()
    function totalSupply() public view returns (uint) {
        require(!depricated);
        return _totalSupply;
    }
    
    //balanceOf use for the get balance of address.
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        if(depricated) return upgred.balanceOfByLegecy(tokenOwner);
        else return balances[tokenOwner];
    }
    
    //setHolder use in transfer to insert holders into Holders[].
    function setHolder(address _holername) internal{
        bool exixits=false;
        for(uint i=0;i<holder.length;i++)
            if(_holername==holder[i])
                exixits=true;
                
        if(!exixits) holder.push(_holername);
    }
    
    //UpgradContract method use for depricate the contract.
    //after UpgradContract only transfer,balanceOf methods will working.
    //@param _newcontract is address of new upgred contract.
    function UpgradContract(address payable _newcontract) public payable{
        upgred=Upgred(_newcontract);
        depricated=true;
    }
    
    //to get array of Holders who perform transfer via this contract.
    function getHolder() public view returns (address[] memory) {
        return holder;
    }
    
    // Standard function transfer similar to ERC20 transfer with no _data . 
    // Added due to backwards compatibility reasons .
    function transfer(address to, uint tokens) public IsAutheticate returns (bool success) {
      
        //standard function transfer similar to ERC20 transfer with no _data 
        //added due to backwards compatibility reasons
        require(!isBlackListed[msg.sender] && !isBlackListed[to]);
        //check sender have enough tokens.
        require (balanceOf(msg.sender) >= tokens);
        //check receiver is not owner of token.
        require (to != msg.sender);
        // Prevent transfer to 0x0 address.
        require(to != address(0));
        //Check transfer value is > 0;
        require (tokens > 0);
        // Check for overflows
        require (balances[to].add(tokens) >= balances[to]);
        bytes memory empty;
        
        if(depricated) 
            return upgred.transferByLegacy(msg.sender, to, tokens, empty);
        else
            super.transfer(to,tokens,empty);
            
        setHolder(to);
    }
    
    // Standard function transfer similar to ERC20 transfer with no _data .
    // Added due to backwards compatibility reasons .
    function transfer(address to, uint tokens,bytes memory data) public IsAutheticate returns (bool success) {
      
        //standard function transfer similar to ERC20 transfer with no _data //added due to backwards compatibility reasons
        require(!isBlackListed[msg.sender] && !isBlackListed[to]);
        //check sender have enough tokens.
        require (balanceOf(msg.sender) >= tokens);
        //check receiver is not owner of token.
        require (to != msg.sender);
        // Prevent transfer to 0x0 address.
        require(to != address(0));
        //Check transfer value is > 0;
        require (tokens > 0);
        // Check for overflows
        require (balances[to].add(tokens) >= balances[to]);
        
        if(depricated)
            return upgred.transferByLegacy(msg.sender, to, tokens, data);
        else
            super.transfer(to,tokens,data);
            
        setHolder(to);
    }
    
    //convertToNewTockens called when contract is depricated.
    //holder's token convert to new upgred tokens via this method.
    //this method can only called by owner of contract.
    function convertToNewTockens() public onlyOwner returns (bool) {
        require(depricated);
        
        uint amount;
        for(uint i=0; i<holder.length; i++){
            amount = balances[holder[i]];
            upgred.convertByLegacy(holder[i],amount);
            balances[holder[i]]=0;
        }
        return true;
    }
    
    //for check contract is Autheticate or not
    //@param AuthAddre is address of Autheticate address.
    function IsAuthetic(address AuthAddre) public{
        AuthentiicateInterface auth=AuthentiicateInterface(AuthAddre);
        Autheticate=auth.checkforAuthContract(address(this));
    }
    
    /* ERC621 Standard
    Issue a new amount of tokens
    these tokens are deposited into the owner address
    @param amount Number of tokens to be issued
    */
    function increaseSupply(uint amount) public onlyOwner {
        require(!depricated);
        require(amount <= 10000000);
        amount = amount.mul(10**uint(decimals));
        require(_totalSupply.add(amount) > _totalSupply);
        require(balances[owner].add(amount) > balances[owner]);
        balances[owner] = balances[owner].add(amount);
        _totalSupply = _totalSupply.add(amount);
        emit IncreaseSupply(amount);
    }
    
    /* ERC621 Standard
    Redeem tokens.
    These tokens are withdrawn from the owner address
    if the balance must be enough to cover the redeem
    or the call will fail.
    @param amount Number of tokens to be issued
    */
    function decreaseSupply(uint amount) public onlyOwner {
        require(!depricated);
        require(amount <= 10000000);
        amount = amount.mul(10**uint(decimals));
        require(_totalSupply >= amount);
        require(balances[owner] >= amount);
        _totalSupply = _totalSupply.sub(amount);
        balances[owner] = balances[owner].sub(amount);
        emit DecreaseSupply(amount);
    }
    
    //to destroy tokens of BlackList accounts
    //tokens also remove from the totalSupply.
    function destroyBlackFunds (address _blackListedUser) public onlyOwner {
        require(!depricated);
            require(isBlackListed[_blackListedUser]);
            uint dirtyFunds = balances[_blackListedUser];
            balances[_blackListedUser] = 0;
            _totalSupply = _totalSupply.sub(dirtyFunds);
            emit DestroyedBlackFunds(_blackListedUser, dirtyFunds);
    }
    
    //withdrawForeignTokens for withdraw tokens by mistaccly sent by another contract on our contract.
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ERC223Interface token = ERC223Interface(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
    
    /*onlyOwner is custom modifier
    owner can kill this contract owners address*/
    function destroy(address payable _owner) public onlyOwner{
        require(_owner == owner);
        selfdestruct(_owner);
    }
}