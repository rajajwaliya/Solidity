pragma solidity ^0.5.3;

/**
* @title SafeMath
* @dev Math operations with safety checks that throw on error
*/
library SafeMath {
    /**
    * @dev Adds two numbers, reverts on overflow.
    */
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    
    /**
    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
    address public owner;

    /**
      * @dev The Ownable constructor sets the original `owner` of the contract to the sender
      * account.
      */
    constructor() public {
        owner = msg.sender;
    }

    /**
      * @dev Throws if called by any account other than the owner.
      */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}

/**
*@dev ContractReceiver abstract class that define by erc223, the method tokenFallback must by receiver contract if it want 
* to accept erc223 tokens.
*/
contract ContractReceiver {
    function tokenFallback(address _from, uint _value, bytes memory _data) public;
}

/**
*@dev NewContract is upgred contract that implements Upgred abstract class methods. 
*/
contract NewContract is Ownable {
    
    mapping(address => uint) balances;
    using SafeMath for uint;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public _totalSupply;
    
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens, bytes data);
    
    //totalSupply must have to bigger or qual to the _totalSupply of old contract.
    constructor(string memory _name,string memory _symbol,uint8 _decimals,uint totalSupply) public{
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        _totalSupply = totalSupply * 10**uint(decimals);
        balances[msg.sender] = _totalSupply;
    }
    
    //balanceOf use for the get balance of address.
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }
    
    //convertToNewTockens called by old contract when old contract is depricated.
    //holder's token convert to new upgred tokens via this method.
    function convertByLegacy(address to, uint tokens) public{
        balances[owner] = balances[owner].sub(tokens);
        balances[to] = balances[to].add(tokens);
    }
    
    //function transfer similar to ERC223 old contract transfer with data.
    function transferByLegacy(address from, address to, uint tokens,bytes memory data) public returns (bool success){
        if(isContract(to)) return transferToContract(from, to, tokens, data);
        else return transferToAddress(from, to, tokens, data);
    }
    
    //balanceOf use for the get balance of address.
    function balanceOfByLegecy(address _owner)public view returns(uint balance){
        return balances[_owner];
    }
    
    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.
    function isContract(address _addr) public view returns (bool is_contract) {
        uint length;
        assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
        }
        return (length>0);
    }

    //function that is called when transaction target is an address
    function transferToAddress(address from,address to, uint tokens, bytes memory data) private returns (bool success) {
        require (balanceOf(from) >= tokens);
        balances[from] = balances[from].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        emit Transfer(from, to, tokens, data);
        return true;
    }
  
    //function that is called when transaction target is a contract
    function transferToContract(address from, address to, uint tokens, bytes memory data) private returns (bool success) {
        require (balanceOf(from) >= tokens);
        balances[from] = balances[from].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        ContractReceiver receiver = ContractReceiver(to);
        receiver.tokenFallback(from, tokens, data);
        emit Transfer(from, to, tokens, data);
        return true;
    }
}